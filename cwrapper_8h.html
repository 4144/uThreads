<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>uThreads: src/cwrapper.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">uThreads
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">cwrapper.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>C Wrapper for uThreads.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;pthread.h&gt;</code><br/>
<code>#include &lt;sys/types.h&gt;</code><br/>
<code>#include &lt;sys/socket.h&gt;</code><br/>
<code>#include &lt;inttypes.h&gt;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for cwrapper.h:</div>
<div class="dyncontent">
<div class="center"><img src="cwrapper_8h__incl.png" border="0" usemap="#src_2cwrapper_8h" alt=""/></div>
<map name="src_2cwrapper_8h" id="src_2cwrapper_8h">
</map>
</div>
</div>
<p><a href="cwrapper_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Cluster</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp249694a485fc5d3289c38986b4f8e887"></a>C interface for class <a class="el" href="classCluster.html" title="Scheduler and Cluster of kThreads. ">Cluster</a>. </p>
</td></tr>
<tr class="memitem:a41cb5b0d298888eed8737fd569c108e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41cb5b0d298888eed8737fd569c108e6"></a>
typedef struct WCluster&#160;</td><td class="memItemRight" valign="bottom"><b>WCluster</b></td></tr>
<tr class="separator:a41cb5b0d298888eed8737fd569c108e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509ff12e5db4c00772cee38a3ca0f9f3"><td class="memItemLeft" align="right" valign="top">WCluster *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a509ff12e5db4c00772cee38a3ca0f9f3">cluster_create</a> ()</td></tr>
<tr class="separator:a509ff12e5db4c00772cee38a3ca0f9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5a76035ebbcc6669179d55136035c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a7b5a76035ebbcc6669179d55136035c2">cluster_destroy</a> (WCluster *cluster)</td></tr>
<tr class="separator:a7b5a76035ebbcc6669179d55136035c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b787deaa328a14a87e750da0b0bcd56"><td class="memItemLeft" align="right" valign="top">WCluster *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a9b787deaa328a14a87e750da0b0bcd56">cluster_get_default</a> ()</td></tr>
<tr class="separator:a9b787deaa328a14a87e750da0b0bcd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507d996ca366d4789eedb98506dcbe34"><td class="memItemLeft" align="right" valign="top">WCluster *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a507d996ca366d4789eedb98506dcbe34">cluster_get_current</a> ()</td></tr>
<tr class="separator:a507d996ca366d4789eedb98506dcbe34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156dce0703be0193f367f31217eec1d5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a156dce0703be0193f367f31217eec1d5">cluster_get_id</a> (WCluster *cluster)</td></tr>
<tr class="memdesc:a156dce0703be0193f367f31217eec1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID of <a class="el" href="classCluster.html" title="Scheduler and Cluster of kThreads. ">Cluster</a>.  <a href="#a156dce0703be0193f367f31217eec1d5">More...</a><br/></td></tr>
<tr class="separator:a156dce0703be0193f367f31217eec1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7072c363108177ec99ab65cf719143d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#ae7072c363108177ec99ab65cf719143d">cluster_get_number_of_kThreads</a> (WCluster *cluster)</td></tr>
<tr class="memdesc:ae7072c363108177ec99ab65cf719143d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of kThreads belonging to this cluster.  <a href="#ae7072c363108177ec99ab65cf719143d">More...</a><br/></td></tr>
<tr class="separator:ae7072c363108177ec99ab65cf719143d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
kThread</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpba6384690d22712050b53a0074ebcc3c"></a>C interface for class <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a>. </p>
</td></tr>
<tr class="memitem:a17f4a189434c557ee4fe1120fe563776"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17f4a189434c557ee4fe1120fe563776"></a>
typedef struct WkThread&#160;</td><td class="memItemRight" valign="bottom"><b>WkThread</b></td></tr>
<tr class="separator:a17f4a189434c557ee4fe1120fe563776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5eb5dfc073dddbb7de5117a5f8bb3c"><td class="memItemLeft" align="right" valign="top">WkThread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a7f5eb5dfc073dddbb7de5117a5f8bb3c">kThread_create</a> (WCluster *cluster)</td></tr>
<tr class="separator:a7f5eb5dfc073dddbb7de5117a5f8bb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae846688b27c80029594aa2b67a1db453"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#ae846688b27c80029594aa2b67a1db453">kThread_destroy</a> (WkThread *kt)</td></tr>
<tr class="separator:ae846688b27c80029594aa2b67a1db453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d80325ab48650187c1785199546ad2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a72d80325ab48650187c1785199546ad2">kThread_get_total_number_of_kThreads</a> ()</td></tr>
<tr class="separator:a72d80325ab48650187c1785199546ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517c809c42e5efbcb234ab471d6a274f"><td class="memItemLeft" align="right" valign="top">WkThread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a517c809c42e5efbcb234ab471d6a274f">kThread_get_current</a> ()</td></tr>
<tr class="memdesc:a517c809c42e5efbcb234ab471d6a274f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pointer to the current <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a>.  <a href="#a517c809c42e5efbcb234ab471d6a274f">More...</a><br/></td></tr>
<tr class="separator:a517c809c42e5efbcb234ab471d6a274f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739e9a04fd415ab87870c1e971742e4b"><td class="memItemLeft" align="right" valign="top">pthread_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a739e9a04fd415ab87870c1e971742e4b">kThread_get_current_pthread_id</a> ()</td></tr>
<tr class="memdesc:a739e9a04fd415ab87870c1e971742e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the native handle for the kernel thread  <a href="#a739e9a04fd415ab87870c1e971742e4b">More...</a><br/></td></tr>
<tr class="separator:a739e9a04fd415ab87870c1e971742e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78baa2ebc4d541e075d5ac481269cc7"><td class="memItemLeft" align="right" valign="top">pthread_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#aa78baa2ebc4d541e075d5ac481269cc7">kThread_get_pthread_id</a> (WkThread *kt)</td></tr>
<tr class="memdesc:aa78baa2ebc4d541e075d5ac481269cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the native handle for the kernel thread  <a href="#aa78baa2ebc4d541e075d5ac481269cc7">More...</a><br/></td></tr>
<tr class="separator:aa78baa2ebc4d541e075d5ac481269cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
uThread</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp9525c0b1f95c33989618d4f1dd10ad92"></a>C interface for class <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a>. </p>
</td></tr>
<tr class="memitem:aa495c2e3778821f92d1f92e85930e61c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa495c2e3778821f92d1f92e85930e61c"></a>
typedef struct WuThread&#160;</td><td class="memItemRight" valign="bottom"><b>WuThread</b></td></tr>
<tr class="separator:aa495c2e3778821f92d1f92e85930e61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd14530be3fea8cf9204f70cd9e4b9e"><td class="memItemLeft" align="right" valign="top">WuThread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#acfd14530be3fea8cf9204f70cd9e4b9e">uThread_create</a> (bool joinable=false)</td></tr>
<tr class="memdesc:acfd14530be3fea8cf9204f70cd9e4b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> with a given stack size.  <a href="#acfd14530be3fea8cf9204f70cd9e4b9e">More...</a><br/></td></tr>
<tr class="separator:acfd14530be3fea8cf9204f70cd9e4b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fe0d5fb1b8c45f0b6c7f21c12721fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#af6fe0d5fb1b8c45f0b6c7f21c12721fb">uThread_start</a> (WuThread *ut, WCluster *cluster, void *func, void *arg1=0, void *arg2=0, void *arg3=0)</td></tr>
<tr class="memdesc:af6fe0d5fb1b8c45f0b6c7f21c12721fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">start the <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> by calling the function passed to it  <a href="#af6fe0d5fb1b8c45f0b6c7f21c12721fb">More...</a><br/></td></tr>
<tr class="separator:af6fe0d5fb1b8c45f0b6c7f21c12721fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae884ed2490c204350df69b54ebe62c18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#ae884ed2490c204350df69b54ebe62c18">uThread_migrate</a> (WCluster *cluster)</td></tr>
<tr class="memdesc:ae884ed2490c204350df69b54ebe62c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> to the provided cluster.  <a href="#ae884ed2490c204350df69b54ebe62c18">More...</a><br/></td></tr>
<tr class="separator:ae884ed2490c204350df69b54ebe62c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042b0598787dfca933132305f9324e4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a042b0598787dfca933132305f9324e4c">uThread_terminate</a> (WuThread *ut)</td></tr>
<tr class="memdesc:a042b0598787dfca933132305f9324e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates the <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a>.  <a href="#a042b0598787dfca933132305f9324e4c">More...</a><br/></td></tr>
<tr class="separator:a042b0598787dfca933132305f9324e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8091f1b2362987907c2fba1c77af5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a4d8091f1b2362987907c2fba1c77af5c">uThread_yield</a> ()</td></tr>
<tr class="memdesc:a4d8091f1b2362987907c2fba1c77af5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> to yield.  <a href="#a4d8091f1b2362987907c2fba1c77af5c">More...</a><br/></td></tr>
<tr class="separator:a4d8091f1b2362987907c2fba1c77af5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350a033acc8970710b72d31b0ead6d4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a350a033acc8970710b72d31b0ead6d4b">uThread_join</a> (WuThread *ut)</td></tr>
<tr class="memdesc:a350a033acc8970710b72d31b0ead6d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> to finish execution and exit.  <a href="#a350a033acc8970710b72d31b0ead6d4b">More...</a><br/></td></tr>
<tr class="separator:a350a033acc8970710b72d31b0ead6d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc04089100a2af87d1b94c5c6a58fdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a5bc04089100a2af87d1b94c5c6a58fdc">uThread_detach</a> (WuThread *ut)</td></tr>
<tr class="memdesc:a5bc04089100a2af87d1b94c5c6a58fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach a joinable thread.  <a href="#a5bc04089100a2af87d1b94c5c6a58fdc">More...</a><br/></td></tr>
<tr class="separator:a5bc04089100a2af87d1b94c5c6a58fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2aa0519b9655b2a295653f8fab0a01"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#add2aa0519b9655b2a295653f8fab0a01">uThread_get_id</a> (WuThread *ut)</td></tr>
<tr class="memdesc:add2aa0519b9655b2a295653f8fab0a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the ID of this <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a>  <a href="#add2aa0519b9655b2a295653f8fab0a01">More...</a><br/></td></tr>
<tr class="separator:add2aa0519b9655b2a295653f8fab0a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae327f6468bf4aeba31243ef5cd49fcdc"><td class="memItemLeft" align="right" valign="top">WuThread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#ae327f6468bf4aeba31243ef5cd49fcdc">uThread_get_current</a> ()</td></tr>
<tr class="memdesc:ae327f6468bf4aeba31243ef5cd49fcdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the current running <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a>.  <a href="#ae327f6468bf4aeba31243ef5cd49fcdc">More...</a><br/></td></tr>
<tr class="separator:ae327f6468bf4aeba31243ef5cd49fcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aff17b56e583c76add0913790f472f2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a0aff17b56e583c76add0913790f472f2">uThread_get_total_number_of_uThreads</a> ()</td></tr>
<tr class="separator:a0aff17b56e583c76add0913790f472f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Connection</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpc2cc7082a89c1ad6631a2f66af5f00c0"></a>C interface for class <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a>. </p>
</td></tr>
<tr class="memitem:acaa438d2c17f37e062c7b62c7eef6523"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaa438d2c17f37e062c7b62c7eef6523"></a>
typedef struct WConnection&#160;</td><td class="memItemRight" valign="bottom"><b>WConnection</b></td></tr>
<tr class="separator:acaa438d2c17f37e062c7b62c7eef6523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae317fbf41ce2b18f9818f22743717114"><td class="memItemLeft" align="right" valign="top">WConnection *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#ae317fbf41ce2b18f9818f22743717114">connection_create</a> ()</td></tr>
<tr class="memdesc:ae317fbf41ce2b18f9818f22743717114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a> that does not have.  <a href="#ae317fbf41ce2b18f9818f22743717114">More...</a><br/></td></tr>
<tr class="separator:ae317fbf41ce2b18f9818f22743717114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3840f54474abb73464f4918c654b899a"><td class="memItemLeft" align="right" valign="top">WConnection *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a3840f54474abb73464f4918c654b899a">connection_create_with_fd</a> (int fd)</td></tr>
<tr class="memdesc:a3840f54474abb73464f4918c654b899a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a connection object with the provided fd.  <a href="#a3840f54474abb73464f4918c654b899a">More...</a><br/></td></tr>
<tr class="separator:a3840f54474abb73464f4918c654b899a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6320684bda95d6ce0751233ba96a4058"><td class="memItemLeft" align="right" valign="top">WConnection *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a6320684bda95d6ce0751233ba96a4058">connection_create_on_cluster</a> (WCluster *cluster, int fd)</td></tr>
<tr class="memdesc:a6320684bda95d6ce0751233ba96a4058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a connection object with the provided fd, and add it to the poller thread of the provided cluster.  <a href="#a6320684bda95d6ce0751233ba96a4058">More...</a><br/></td></tr>
<tr class="separator:a6320684bda95d6ce0751233ba96a4058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50535c8cf23aa62721f30a24fdb9ff98"><td class="memItemLeft" align="right" valign="top">WConnection *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a50535c8cf23aa62721f30a24fdb9ff98">connection_create_socket</a> (int domain, int type, int protocol)</td></tr>
<tr class="memdesc:a50535c8cf23aa62721f30a24fdb9ff98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as socket syscall adds | SOCK_NONBLOCK to type.  <a href="#a50535c8cf23aa62721f30a24fdb9ff98">More...</a><br/></td></tr>
<tr class="separator:a50535c8cf23aa62721f30a24fdb9ff98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94ab0cf5233a73e22c3b2dd506c1e37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#aa94ab0cf5233a73e22c3b2dd506c1e37">connection_destory</a> (WConnection *c)</td></tr>
<tr class="separator:aa94ab0cf5233a73e22c3b2dd506c1e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab021622e001dcf6be50d4b5a7acd11c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#ab021622e001dcf6be50d4b5a7acd11c5">connection_accept</a> (WConnection *acceptor, WConnection *conn, struct sockaddr *addr, socklen_t *addrlen)</td></tr>
<tr class="memdesc:ab021622e001dcf6be50d4b5a7acd11c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">nonblocking accept syscall and updating the passed <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a> object  <a href="#ab021622e001dcf6be50d4b5a7acd11c5">More...</a><br/></td></tr>
<tr class="separator:ab021622e001dcf6be50d4b5a7acd11c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e606a63cb5d2a50aab3ec59c66dc999"><td class="memItemLeft" align="right" valign="top">WConnection *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a9e606a63cb5d2a50aab3ec59c66dc999">connection_accept_connenction</a> (WConnection *acceptor, struct sockaddr *addr, socklen_t *addrlen)</td></tr>
<tr class="memdesc:a9e606a63cb5d2a50aab3ec59c66dc999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accepts a connection and returns a connection object.  <a href="#a9e606a63cb5d2a50aab3ec59c66dc999">More...</a><br/></td></tr>
<tr class="separator:a9e606a63cb5d2a50aab3ec59c66dc999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673134dedcf33e103bc8759f5f582f2b"><td class="memItemLeft" align="right" valign="top">WConnection *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a673134dedcf33e103bc8759f5f582f2b">connection_accept_on_cluster</a> (WConnection *acceptor, WCluster *cluster, struct sockaddr *addr, socklen_t *addrlen)</td></tr>
<tr class="memdesc:a673134dedcf33e103bc8759f5f582f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accepts a connection, adds it to the poller thread of the provided cluster, and returns a connection object.  <a href="#a673134dedcf33e103bc8759f5f582f2b">More...</a><br/></td></tr>
<tr class="separator:a673134dedcf33e103bc8759f5f582f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077ae4256e6e0de88a6d099d63d868f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a077ae4256e6e0de88a6d099d63d868f0">connection_socket</a> (WConnection *conn, int domain, int type, int protocol)</td></tr>
<tr class="memdesc:a077ae4256e6e0de88a6d099d63d868f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as socket syscall, set the fd for current connection.  <a href="#a077ae4256e6e0de88a6d099d63d868f0">More...</a><br/></td></tr>
<tr class="separator:a077ae4256e6e0de88a6d099d63d868f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332a26382d1ab23753cea6d296d18b02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a332a26382d1ab23753cea6d296d18b02">connection_listen</a> (WConnection *conn, int backlog)</td></tr>
<tr class="memdesc:a332a26382d1ab23753cea6d296d18b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as listen syscall on current fd.  <a href="#a332a26382d1ab23753cea6d296d18b02">More...</a><br/></td></tr>
<tr class="separator:a332a26382d1ab23753cea6d296d18b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ec77dd60ad38ae0368e7ff246f220c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#ae1ec77dd60ad38ae0368e7ff246f220c">connection_bind</a> (WConnection *conn, const struct sockaddr *addr, socklen_t addrlen)</td></tr>
<tr class="memdesc:ae1ec77dd60ad38ae0368e7ff246f220c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as bind syscall.  <a href="#ae1ec77dd60ad38ae0368e7ff246f220c">More...</a><br/></td></tr>
<tr class="separator:ae1ec77dd60ad38ae0368e7ff246f220c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb081e751aa59599722780c6aaa51f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a9bb081e751aa59599722780c6aaa51f9">connection_connect</a> (WConnection *conn, const struct sockaddr *addr, socklen_t addrlen)</td></tr>
<tr class="memdesc:a9bb081e751aa59599722780c6aaa51f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as connect syscall.  <a href="#a9bb081e751aa59599722780c6aaa51f9">More...</a><br/></td></tr>
<tr class="separator:a9bb081e751aa59599722780c6aaa51f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737cdaedd16eddf3180f54e7da230800"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a737cdaedd16eddf3180f54e7da230800">connection_close</a> (WConnection *conn)</td></tr>
<tr class="memdesc:a737cdaedd16eddf3180f54e7da230800"><td class="mdescLeft">&#160;</td><td class="mdescRight">closes the socket  <a href="#a737cdaedd16eddf3180f54e7da230800">More...</a><br/></td></tr>
<tr class="separator:a737cdaedd16eddf3180f54e7da230800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf92a7ef3839621e24505ee38aa596da"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#abf92a7ef3839621e24505ee38aa596da">connection_recv</a> (WConnection *conn, void *buf, size_t len, int flags)</td></tr>
<tr class="memdesc:abf92a7ef3839621e24505ee38aa596da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the underlying system call on <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a>'s file descriptor.  <a href="#abf92a7ef3839621e24505ee38aa596da">More...</a><br/></td></tr>
<tr class="separator:abf92a7ef3839621e24505ee38aa596da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9fe29587505b3312b6f55f35322c93"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a9d9fe29587505b3312b6f55f35322c93">connection_recvfrom</a> (WConnection *conn, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen)</td></tr>
<tr class="memdesc:a9d9fe29587505b3312b6f55f35322c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the underlying system call on <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a>'s file descriptor.  <a href="#a9d9fe29587505b3312b6f55f35322c93">More...</a><br/></td></tr>
<tr class="separator:a9d9fe29587505b3312b6f55f35322c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154967f985db20264f788761477b8931"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a154967f985db20264f788761477b8931">connection_recvmsg</a> (WConnection *conn, int sockfd, struct msghdr *msg, int flags)</td></tr>
<tr class="memdesc:a154967f985db20264f788761477b8931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the underlying system call on <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a>'s file descriptor.  <a href="#a154967f985db20264f788761477b8931">More...</a><br/></td></tr>
<tr class="separator:a154967f985db20264f788761477b8931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4f363bbc3b9d83d0e71a7f779c5f14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a4e4f363bbc3b9d83d0e71a7f779c5f14">connection_recvmmsg</a> (WConnection *conn, int sockfd, struct mmsghdr *msgvec, unsigned int vlen, unsigned int flags, struct timespec *timeout)</td></tr>
<tr class="memdesc:a4e4f363bbc3b9d83d0e71a7f779c5f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the underlying system call on <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a>'s file descriptor.  <a href="#a4e4f363bbc3b9d83d0e71a7f779c5f14">More...</a><br/></td></tr>
<tr class="separator:a4e4f363bbc3b9d83d0e71a7f779c5f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d5ae2bee8141f48178269e1fd60a46"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a40d5ae2bee8141f48178269e1fd60a46">connection_send</a> (WConnection *conn, const void *buf, size_t len, int flags)</td></tr>
<tr class="memdesc:a40d5ae2bee8141f48178269e1fd60a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the underlying system call on <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a>'s file descriptor.  <a href="#a40d5ae2bee8141f48178269e1fd60a46">More...</a><br/></td></tr>
<tr class="separator:a40d5ae2bee8141f48178269e1fd60a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff47c532b5903b220818e30ac8293d2"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a6ff47c532b5903b220818e30ac8293d2">connection_sendto</a> (WConnection *conn, int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen)</td></tr>
<tr class="memdesc:a6ff47c532b5903b220818e30ac8293d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the underlying system call on <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a>'s file descriptor.  <a href="#a6ff47c532b5903b220818e30ac8293d2">More...</a><br/></td></tr>
<tr class="separator:a6ff47c532b5903b220818e30ac8293d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fc64a8f07fd2c2fc01e3deea5a495b"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#ab0fc64a8f07fd2c2fc01e3deea5a495b">connection_sendmsg</a> (WConnection *conn, const struct msghdr *msg, int flags)</td></tr>
<tr class="memdesc:ab0fc64a8f07fd2c2fc01e3deea5a495b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the underlying system call on <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a>'s file descriptor.  <a href="#ab0fc64a8f07fd2c2fc01e3deea5a495b">More...</a><br/></td></tr>
<tr class="separator:ab0fc64a8f07fd2c2fc01e3deea5a495b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a3df262c2416475b28a595b8c50eec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#af0a3df262c2416475b28a595b8c50eec">connection_sendmmsg</a> (WConnection *conn, int sockfd, struct mmsghdr *msgvec, unsigned int vlen, unsigned int flags)</td></tr>
<tr class="memdesc:af0a3df262c2416475b28a595b8c50eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the underlying system call on <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a>'s file descriptor.  <a href="#af0a3df262c2416475b28a595b8c50eec">More...</a><br/></td></tr>
<tr class="separator:af0a3df262c2416475b28a595b8c50eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7d9590f682b337b88bc15ab61b152f"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#abc7d9590f682b337b88bc15ab61b152f">connection_read</a> (WConnection *conn, void *buf, size_t count)</td></tr>
<tr class="memdesc:abc7d9590f682b337b88bc15ab61b152f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the underlying system call on <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a>'s file descriptor.  <a href="#abc7d9590f682b337b88bc15ab61b152f">More...</a><br/></td></tr>
<tr class="separator:abc7d9590f682b337b88bc15ab61b152f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0250cd403890768ddba33a50e5293d8"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#aa0250cd403890768ddba33a50e5293d8">connection_write</a> (WConnection *conn, const void *buf, size_t count)</td></tr>
<tr class="memdesc:aa0250cd403890768ddba33a50e5293d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the underlying system call on <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a>'s file descriptor.  <a href="#aa0250cd403890768ddba33a50e5293d8">More...</a><br/></td></tr>
<tr class="separator:aa0250cd403890768ddba33a50e5293d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a407f03224f6d9ccd0686ef002c668f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a9a407f03224f6d9ccd0686ef002c668f">connection_block_on_read</a> (WConnection *conn)</td></tr>
<tr class="memdesc:a9a407f03224f6d9ccd0686ef002c668f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a>, waiting for fd to become ready for read.  <a href="#a9a407f03224f6d9ccd0686ef002c668f">More...</a><br/></td></tr>
<tr class="separator:a9a407f03224f6d9ccd0686ef002c668f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b64ee94bbea1e3a4d0b4ca499a9676e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a4b64ee94bbea1e3a4d0b4ca499a9676e">connection_block_on_write</a> (WConnection *conn)</td></tr>
<tr class="memdesc:a4b64ee94bbea1e3a4d0b4ca499a9676e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a>, waiting for fd to become ready for write.  <a href="#a4b64ee94bbea1e3a4d0b4ca499a9676e">More...</a><br/></td></tr>
<tr class="separator:a4b64ee94bbea1e3a4d0b4ca499a9676e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f7b4d16aa7f3670e894a0cdcaa6177"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#aa2f7b4d16aa7f3670e894a0cdcaa6177">connection_get_fd</a> (WConnection *conn)</td></tr>
<tr class="separator:aa2f7b4d16aa7f3670e894a0cdcaa6177"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Mutex</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp648c65b85d6dae62ee3d0130b0da2f01"></a>C interface for class <a class="el" href="classMutex.html" title="A user-level Mutex. ">Mutex</a>. </p>
</td></tr>
<tr class="memitem:a3efb4657e171b3b0d65edd4760b1c719"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3efb4657e171b3b0d65edd4760b1c719"></a>
typedef struct WMutex&#160;</td><td class="memItemRight" valign="bottom"><b>WMutex</b></td></tr>
<tr class="separator:a3efb4657e171b3b0d65edd4760b1c719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eedd424319e0496a248313292dc6fb6"><td class="memItemLeft" align="right" valign="top">WMutex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a4eedd424319e0496a248313292dc6fb6">mutex_create</a> ()</td></tr>
<tr class="separator:a4eedd424319e0496a248313292dc6fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f88f3df3a2dcd5dfb38b193582c203"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a90f88f3df3a2dcd5dfb38b193582c203">mutex_destroy</a> (WMutex *mutex)</td></tr>
<tr class="separator:a90f88f3df3a2dcd5dfb38b193582c203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a399f1731f55f8b96c675a6ad0b95fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a8a399f1731f55f8b96c675a6ad0b95fd">mutex_acquire</a> (WMutex *mutex)</td></tr>
<tr class="memdesc:a8a399f1731f55f8b96c675a6ad0b95fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">acquire the mutex  <a href="#a8a399f1731f55f8b96c675a6ad0b95fd">More...</a><br/></td></tr>
<tr class="separator:a8a399f1731f55f8b96c675a6ad0b95fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46276d6fc0bb28fa51bdaa283ce25e81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a46276d6fc0bb28fa51bdaa283ce25e81">mutex_release</a> (WMutex *mutex)</td></tr>
<tr class="memdesc:a46276d6fc0bb28fa51bdaa283ce25e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">release the <a class="el" href="classMutex.html" title="A user-level Mutex. ">Mutex</a>  <a href="#a46276d6fc0bb28fa51bdaa283ce25e81">More...</a><br/></td></tr>
<tr class="separator:a46276d6fc0bb28fa51bdaa283ce25e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
OwnerLock</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpa5371e7c84d1743e5909639b8eddade6"></a>C interface for class <a class="el" href="classOwnerLock.html" title="an Owner Mutex where owner can recursively acquire the Mutex ">OwnerLock</a>. </p>
</td></tr>
<tr class="memitem:a788807dc4e230bbdd2486ea63d8156cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a788807dc4e230bbdd2486ea63d8156cb"></a>
typedef struct WOwnerLock&#160;</td><td class="memItemRight" valign="bottom"><b>WOwnerLock</b></td></tr>
<tr class="separator:a788807dc4e230bbdd2486ea63d8156cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae660d3dac08a4bdc8aadc9be061ac27c"><td class="memItemLeft" align="right" valign="top">WOwnerLock *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#ae660d3dac08a4bdc8aadc9be061ac27c">ownerlock_create</a> ()</td></tr>
<tr class="separator:ae660d3dac08a4bdc8aadc9be061ac27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c58b151ee7b8b5aa72bdb2c3b2ec954"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a3c58b151ee7b8b5aa72bdb2c3b2ec954">ownerlock_destroy</a> (WOwnerLock *olock)</td></tr>
<tr class="separator:a3c58b151ee7b8b5aa72bdb2c3b2ec954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ffa94dec85175c95050dfc5ca43775"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#af1ffa94dec85175c95050dfc5ca43775">ownerlock_acquire</a> (WOwnerLock *olock)</td></tr>
<tr class="separator:af1ffa94dec85175c95050dfc5ca43775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d52ca13b0fdd683f06e0a0827d4c00a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a0d52ca13b0fdd683f06e0a0827d4c00a">ownerlock_release</a> (WOwnerLock *olock)</td></tr>
<tr class="separator:a0d52ca13b0fdd683f06e0a0827d4c00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
ConditionVariable</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpe1a12d4bd0bbad4f98a03932ccd1953d"></a>C interface for class <a class="el" href="classConditionVariable.html" title="A user level condition variable. ">ConditionVariable</a>. </p>
</td></tr>
<tr class="memitem:a64b95b76afbdc2da4e86c5e665861f98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64b95b76afbdc2da4e86c5e665861f98"></a>
typedef struct WConditionVariable&#160;</td><td class="memItemRight" valign="bottom"><b>WConditionVariable</b></td></tr>
<tr class="separator:a64b95b76afbdc2da4e86c5e665861f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a4abab144ae1709be43ef3941c467a"><td class="memItemLeft" align="right" valign="top">WConditionVariable *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#ae5a4abab144ae1709be43ef3941c467a">condition_variable_create</a> ()</td></tr>
<tr class="separator:ae5a4abab144ae1709be43ef3941c467a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1dbc852a974f0e4f9237aa33322c12f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#ad1dbc852a974f0e4f9237aa33322c12f">condition_variable_destroy</a> (WConditionVariable *cv)</td></tr>
<tr class="separator:ad1dbc852a974f0e4f9237aa33322c12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad7ff9eef06700c025461bffca32e59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#acad7ff9eef06700c025461bffca32e59">condition_variable_wait</a> (WConditionVariable *cv, WMutex *mutex)</td></tr>
<tr class="memdesc:acad7ff9eef06700c025461bffca32e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> on the condition variable using the provided mutex.  <a href="#acad7ff9eef06700c025461bffca32e59">More...</a><br/></td></tr>
<tr class="separator:acad7ff9eef06700c025461bffca32e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24270de149b6c76cac0b8d1a0ace019"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#ae24270de149b6c76cac0b8d1a0ace019">condition_variable_signal</a> (WConditionVariable *cv, WMutex *mutex)</td></tr>
<tr class="memdesc:ae24270de149b6c76cac0b8d1a0ace019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unblock one <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> waiting on the condition variable.  <a href="#ae24270de149b6c76cac0b8d1a0ace019">More...</a><br/></td></tr>
<tr class="separator:ae24270de149b6c76cac0b8d1a0ace019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f68e52c6eb028cb6941b980c6389347"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a4f68e52c6eb028cb6941b980c6389347">condition_variable_signall_all</a> (WConditionVariable *cv, WMutex *mutex)</td></tr>
<tr class="memdesc:a4f68e52c6eb028cb6941b980c6389347"><td class="mdescLeft">&#160;</td><td class="mdescRight">unblock all uThreads waiting on the condition variable  <a href="#a4f68e52c6eb028cb6941b980c6389347">More...</a><br/></td></tr>
<tr class="separator:a4f68e52c6eb028cb6941b980c6389347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578427cd83197083b12b5a0433b776cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a578427cd83197083b12b5a0433b776cd">condition_variable_empty</a> (WConditionVariable *cv)</td></tr>
<tr class="memdesc:a578427cd83197083b12b5a0433b776cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the waiting list is empty or not.  <a href="#a578427cd83197083b12b5a0433b776cd">More...</a><br/></td></tr>
<tr class="separator:a578427cd83197083b12b5a0433b776cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Semaphore</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpf9145352f6358db8f2a94a937b23ba86"></a>C interface for class <a class="el" href="classSemaphore.html" title="A user-level Semaphore. ">Semaphore</a>. </p>
</td></tr>
<tr class="memitem:afbe32f69169881fc2afa9ed9a824f287"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbe32f69169881fc2afa9ed9a824f287"></a>
typedef struct WSemaphore&#160;</td><td class="memItemRight" valign="bottom"><b>WSemaphore</b></td></tr>
<tr class="separator:afbe32f69169881fc2afa9ed9a824f287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50871266a50c5bc215f8a2ce43da9242"><td class="memItemLeft" align="right" valign="top">WSemaphore *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a50871266a50c5bc215f8a2ce43da9242">semaphore_create</a> ()</td></tr>
<tr class="memdesc:a50871266a50c5bc215f8a2ce43da9242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classSemaphore.html" title="A user-level Semaphore. ">Semaphore</a>.  <a href="#a50871266a50c5bc215f8a2ce43da9242">More...</a><br/></td></tr>
<tr class="separator:a50871266a50c5bc215f8a2ce43da9242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904d4b9b3a1cf0eb4ce5884d1c23163f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a904d4b9b3a1cf0eb4ce5884d1c23163f">semaphore_destroy</a> (WSemaphore *sem)</td></tr>
<tr class="separator:a904d4b9b3a1cf0eb4ce5884d1c23163f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d486fae5c32dc6e7f843f99b41f9a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#ae5d486fae5c32dc6e7f843f99b41f9a7">semaphore_p</a> (WSemaphore *sem)</td></tr>
<tr class="memdesc:ae5d486fae5c32dc6e7f843f99b41f9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the value of the <a class="el" href="classSemaphore.html" title="A user-level Semaphore. ">Semaphore</a>.  <a href="#ae5d486fae5c32dc6e7f843f99b41f9a7">More...</a><br/></td></tr>
<tr class="separator:ae5d486fae5c32dc6e7f843f99b41f9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f0fa11b8e1ad60c8aa55c506d392d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cwrapper_8h.html#a34f0fa11b8e1ad60c8aa55c506d392d4">semaphore_v</a> (WSemaphore *sem)</td></tr>
<tr class="memdesc:a34f0fa11b8e1ad60c8aa55c506d392d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">increment the value of the <a class="el" href="classSemaphore.html" title="A user-level Semaphore. ">Semaphore</a>  <a href="#a34f0fa11b8e1ad60c8aa55c506d392d4">More...</a><br/></td></tr>
<tr class="separator:a34f0fa11b8e1ad60c8aa55c506d392d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
uThreadPool</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp666eca647338ca992b265b12f58f28b6"></a>C interface for class uThreadPool. </p>
</td></tr>
<tr class="memitem:a8fc048ec0a9bb5fcf0781e1b99bae410"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fc048ec0a9bb5fcf0781e1b99bae410"></a>
typedef struct WuThreadPool&#160;</td><td class="memItemRight" valign="bottom"><b>WuThreadPool</b></td></tr>
<tr class="separator:a8fc048ec0a9bb5fcf0781e1b99bae410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5059cb8ed5f76c87e00d75a3f2dbde8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5059cb8ed5f76c87e00d75a3f2dbde8c"></a>
WuThreadPool *&#160;</td><td class="memItemRight" valign="bottom"><b>uthreadpool_create</b> ()</td></tr>
<tr class="separator:a5059cb8ed5f76c87e00d75a3f2dbde8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb62479fcff3dab0f67ae8376e8e861b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb62479fcff3dab0f67ae8376e8e861b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>uthreadpool_destory</b> (WuThreadPool *utp)</td></tr>
<tr class="separator:adb62479fcff3dab0f67ae8376e8e861b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8b62e4415f4f0043efa230e544d729"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb8b62e4415f4f0043efa230e544d729"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>uthreadpool_execute</b> (WuThreadPool *utp, WCluster *cluster, void *(*start_routine)(void *), void *arg)</td></tr>
<tr class="separator:adb8b62e4415f4f0043efa230e544d729"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>C Wrapper for uThreads. </p>
<dl class="section author"><dt>Author</dt><dd>Saman Barghi </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a509ff12e5db4c00772cee38a3ca0f9f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WCluster* cluster_create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Create a new <a class="el" href="classCluster.html" title="Scheduler and Cluster of kThreads. ">Cluster</a> </p>

</div>
</div>
<a class="anchor" id="a7b5a76035ebbcc6669179d55136035c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cluster_destroy </td>
          <td>(</td>
          <td class="paramtype">WCluster *&#160;</td>
          <td class="paramname"><em>cluster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Destroy the cluster </p>

</div>
</div>
<a class="anchor" id="a507d996ca366d4789eedb98506dcbe34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WCluster* cluster_get_current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a9b787deaa328a14a87e750da0b0bcd56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WCluster* cluster_get_default </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>defaultCluster</dd></dl>

</div>
</div>
<a class="anchor" id="a156dce0703be0193f367f31217eec1d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cluster_get_id </td>
          <td>(</td>
          <td class="paramtype">WCluster *&#160;</td>
          <td class="paramname"><em>cluster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the ID of <a class="el" href="classCluster.html" title="Scheduler and Cluster of kThreads. ">Cluster</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The ID of the cluster </dd></dl>

</div>
</div>
<a class="anchor" id="ae7072c363108177ec99ab65cf719143d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cluster_get_number_of_kThreads </td>
          <td>(</td>
          <td class="paramtype">WCluster *&#160;</td>
          <td class="paramname"><em>cluster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total number of kThreads belonging to this cluster. </p>
<dl class="section return"><dt>Returns</dt><dd>Total number of kThreads belonging to this cluster </dd></dl>

</div>
</div>
<a class="anchor" id="ae5a4abab144ae1709be43ef3941c467a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WConditionVariable* condition_variable_create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="ad1dbc852a974f0e4f9237aa33322c12f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void condition_variable_destroy </td>
          <td>(</td>
          <td class="paramtype">WConditionVariable *&#160;</td>
          <td class="paramname"><em>cv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a578427cd83197083b12b5a0433b776cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool condition_variable_empty </td>
          <td>(</td>
          <td class="paramtype">WConditionVariable *&#160;</td>
          <td class="paramname"><em>cv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the waiting list is empty or not. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the waiting list is empty or not </dd></dl>

</div>
</div>
<a class="anchor" id="ae24270de149b6c76cac0b8d1a0ace019"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void condition_variable_signal </td>
          <td>(</td>
          <td class="paramtype">WConditionVariable *&#160;</td>
          <td class="paramname"><em>cv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WMutex *&#160;</td>
          <td class="paramname"><em>mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unblock one <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> waiting on the condition variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>The mutex to be released after unblocking is done </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f68e52c6eb028cb6941b980c6389347"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void condition_variable_signall_all </td>
          <td>(</td>
          <td class="paramtype">WConditionVariable *&#160;</td>
          <td class="paramname"><em>cv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WMutex *&#160;</td>
          <td class="paramname"><em>mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unblock all uThreads waiting on the condition variable </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>The mutex to be released after unblocking is done </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acad7ff9eef06700c025461bffca32e59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void condition_variable_wait </td>
          <td>(</td>
          <td class="paramtype">WConditionVariable *&#160;</td>
          <td class="paramname"><em>cv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WMutex *&#160;</td>
          <td class="paramname"><em>mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> on the condition variable using the provided mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>used to synchronize access to the condition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab021622e001dcf6be50d4b5a7acd11c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_accept </td>
          <td>(</td>
          <td class="paramtype">WConnection *&#160;</td>
          <td class="paramname"><em>acceptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WConnection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>nonblocking accept syscall and updating the passed <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a> object </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Pointer to a <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a> object that is not initialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>same as accept system call</dd></dl>
<p>This format is used for compatibility with C </p>

</div>
</div>
<a class="anchor" id="a9e606a63cb5d2a50aab3ec59c66dc999"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WConnection* connection_accept_connenction </td>
          <td>(</td>
          <td class="paramtype">WConnection *&#160;</td>
          <td class="paramname"><em>acceptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accepts a connection and returns a connection object. </p>
<dl class="section return"><dt>Returns</dt><dd>Newly created connection</dd></dl>
<p>Throws a std::system_error exception on error. Never call from C. </p>

</div>
</div>
<a class="anchor" id="a673134dedcf33e103bc8759f5f582f2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WConnection* connection_accept_on_cluster </td>
          <td>(</td>
          <td class="paramtype">WConnection *&#160;</td>
          <td class="paramname"><em>acceptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WCluster *&#160;</td>
          <td class="paramname"><em>cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accepts a connection, adds it to the poller thread of the provided cluster, and returns a connection object. </p>
<dl class="section return"><dt>Returns</dt><dd>Newly created connection</dd></dl>
<p>Throws a std::system_error exception on error. Never call from C. </p>

</div>
</div>
<a class="anchor" id="ae1ec77dd60ad38ae0368e7ff246f220c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_bind </td>
          <td>(</td>
          <td class="paramtype">WConnection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as bind syscall. </p>
<dl class="section return"><dt>Returns</dt><dd>Same as bind syscall </dd></dl>

</div>
</div>
<a class="anchor" id="a9a407f03224f6d9ccd0686ef002c668f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_block_on_read </td>
          <td>(</td>
          <td class="paramtype">WConnection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a>, waiting for fd to become ready for read. </p>

</div>
</div>
<a class="anchor" id="a4b64ee94bbea1e3a4d0b4ca499a9676e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_block_on_write </td>
          <td>(</td>
          <td class="paramtype">WConnection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a>, waiting for fd to become ready for write. </p>

</div>
</div>
<a class="anchor" id="a737cdaedd16eddf3180f54e7da230800"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_close </td>
          <td>(</td>
          <td class="paramtype">WConnection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>closes the socket </p>
<dl class="section return"><dt>Returns</dt><dd>the same as close system call </dd></dl>

</div>
</div>
<a class="anchor" id="a9bb081e751aa59599722780c6aaa51f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_connect </td>
          <td>(</td>
          <td class="paramtype">WConnection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as connect syscall. </p>
<dl class="section return"><dt>Returns</dt><dd>Same as connect syscall </dd></dl>

</div>
</div>
<a class="anchor" id="ae317fbf41ce2b18f9818f22743717114"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WConnection* connection_create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a> that does not have. </p>
<p>This is useful for accept or socket functions that require a <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a> object without fd being set </p>

</div>
</div>
<a class="anchor" id="a6320684bda95d6ce0751233ba96a4058"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WConnection* connection_create_on_cluster </td>
          <td>(</td>
          <td class="paramtype">WCluster *&#160;</td>
          <td class="paramname"><em>cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a connection object with the provided fd, and add it to the poller thread of the provided cluster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>If the connection is already established by other means, set the fd and add it to the polling structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50535c8cf23aa62721f30a24fdb9ff98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WConnection* connection_create_socket </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as socket syscall adds | SOCK_NONBLOCK to type. </p>
<dl class="section return"><dt>Returns</dt><dd>same as socket syscall</dd></dl>
<p>Throws a std::system_error exception. Do not call from C code. The unerlying socket is always nonbelocking. This is achieved by adding a (| SOCK_NONBLOCK) to type, thus requires linux kernels &gt; 2.6.27 </p>

</div>
</div>
<a class="anchor" id="a3840f54474abb73464f4918c654b899a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WConnection* connection_create_with_fd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a connection object with the provided fd. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>If the connection is already established by other means, set the fd and add it to the polling structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa94ab0cf5233a73e22c3b2dd506c1e37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void connection_destory </td>
          <td>(</td>
          <td class="paramtype">WConnection *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="aa2f7b4d16aa7f3670e894a0cdcaa6177"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_get_fd </td>
          <td>(</td>
          <td class="paramtype">WConnection *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a332a26382d1ab23753cea6d296d18b02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_listen </td>
          <td>(</td>
          <td class="paramtype">WConnection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as listen syscall on current fd. </p>
<dl class="section return"><dt>Returns</dt><dd>Same as listen syscall </dd></dl>

</div>
</div>
<a class="anchor" id="abc7d9590f682b337b88bc15ab61b152f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t connection_read </td>
          <td>(</td>
          <td class="paramtype">WConnection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the underlying system call on <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a>'s file descriptor. </p>
<dl class="section return"><dt>Returns</dt><dd>Same as what the related systemcall returns</dd></dl>
<p>This function calls the system call with the same name. If the socket is ready for the required function it returns immediately, otherwise it blocks in the user-level (blocks <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> not <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a>), and polls the file descriptor until it becomes ready.</p>
<p>The return results is the same as the underlying system call except that the following condition is never true when the function returns: (res == -1) &amp;&amp; (errno == EAGAIN || errno == EWOULDBLOCK)</p>
<p>which means the <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a> object does the polling and only returns when an error occurs or the socket is ready. </p>

</div>
</div>
<a class="anchor" id="abf92a7ef3839621e24505ee38aa596da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t connection_recv </td>
          <td>(</td>
          <td class="paramtype">WConnection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the underlying system call on <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a>'s file descriptor. </p>
<dl class="section return"><dt>Returns</dt><dd>Same as what the related systemcall returns</dd></dl>
<p>This function calls the system call with the same name. If the socket is ready for the required function it returns immediately, otherwise it blocks in the user-level (blocks <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> not <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a>), and polls the file descriptor until it becomes ready.</p>
<p>The return results is the same as the underlying system call except that the following condition is never true when the function returns: (res == -1) &amp;&amp; (errno == EAGAIN || errno == EWOULDBLOCK)</p>
<p>which means the <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a> object does the polling and only returns when an error occurs or the socket is ready. </p>

</div>
</div>
<a class="anchor" id="a9d9fe29587505b3312b6f55f35322c93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t connection_recvfrom </td>
          <td>(</td>
          <td class="paramtype">WConnection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&#160;</td>
          <td class="paramname"><em>src_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the underlying system call on <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a>'s file descriptor. </p>
<dl class="section return"><dt>Returns</dt><dd>Same as what the related systemcall returns</dd></dl>
<p>This function calls the system call with the same name. If the socket is ready for the required function it returns immediately, otherwise it blocks in the user-level (blocks <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> not <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a>), and polls the file descriptor until it becomes ready.</p>
<p>The return results is the same as the underlying system call except that the following condition is never true when the function returns: (res == -1) &amp;&amp; (errno == EAGAIN || errno == EWOULDBLOCK)</p>
<p>which means the <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a> object does the polling and only returns when an error occurs or the socket is ready. </p>

</div>
</div>
<a class="anchor" id="a4e4f363bbc3b9d83d0e71a7f779c5f14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_recvmmsg </td>
          <td>(</td>
          <td class="paramtype">WConnection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sockfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct mmsghdr *&#160;</td>
          <td class="paramname"><em>msgvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>vlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the underlying system call on <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a>'s file descriptor. </p>
<dl class="section return"><dt>Returns</dt><dd>Same as what the related systemcall returns</dd></dl>
<p>This function calls the system call with the same name. If the socket is ready for the required function it returns immediately, otherwise it blocks in the user-level (blocks <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> not <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a>), and polls the file descriptor until it becomes ready.</p>
<p>The return results is the same as the underlying system call except that the following condition is never true when the function returns: (res == -1) &amp;&amp; (errno == EAGAIN || errno == EWOULDBLOCK)</p>
<p>which means the <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a> object does the polling and only returns when an error occurs or the socket is ready. </p>

</div>
</div>
<a class="anchor" id="a154967f985db20264f788761477b8931"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t connection_recvmsg </td>
          <td>(</td>
          <td class="paramtype">WConnection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sockfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct msghdr *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the underlying system call on <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a>'s file descriptor. </p>
<dl class="section return"><dt>Returns</dt><dd>Same as what the related systemcall returns</dd></dl>
<p>This function calls the system call with the same name. If the socket is ready for the required function it returns immediately, otherwise it blocks in the user-level (blocks <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> not <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a>), and polls the file descriptor until it becomes ready.</p>
<p>The return results is the same as the underlying system call except that the following condition is never true when the function returns: (res == -1) &amp;&amp; (errno == EAGAIN || errno == EWOULDBLOCK)</p>
<p>which means the <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a> object does the polling and only returns when an error occurs or the socket is ready. </p>

</div>
</div>
<a class="anchor" id="a40d5ae2bee8141f48178269e1fd60a46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t connection_send </td>
          <td>(</td>
          <td class="paramtype">WConnection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the underlying system call on <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a>'s file descriptor. </p>
<dl class="section return"><dt>Returns</dt><dd>Same as what the related systemcall returns</dd></dl>
<p>This function calls the system call with the same name. If the socket is ready for the required function it returns immediately, otherwise it blocks in the user-level (blocks <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> not <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a>), and polls the file descriptor until it becomes ready.</p>
<p>The return results is the same as the underlying system call except that the following condition is never true when the function returns: (res == -1) &amp;&amp; (errno == EAGAIN || errno == EWOULDBLOCK)</p>
<p>which means the <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a> object does the polling and only returns when an error occurs or the socket is ready. </p>

</div>
</div>
<a class="anchor" id="af0a3df262c2416475b28a595b8c50eec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_sendmmsg </td>
          <td>(</td>
          <td class="paramtype">WConnection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sockfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct mmsghdr *&#160;</td>
          <td class="paramname"><em>msgvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>vlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the underlying system call on <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a>'s file descriptor. </p>
<dl class="section return"><dt>Returns</dt><dd>Same as what the related systemcall returns</dd></dl>
<p>This function calls the system call with the same name. If the socket is ready for the required function it returns immediately, otherwise it blocks in the user-level (blocks <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> not <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a>), and polls the file descriptor until it becomes ready.</p>
<p>The return results is the same as the underlying system call except that the following condition is never true when the function returns: (res == -1) &amp;&amp; (errno == EAGAIN || errno == EWOULDBLOCK)</p>
<p>which means the <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a> object does the polling and only returns when an error occurs or the socket is ready. </p>

</div>
</div>
<a class="anchor" id="ab0fc64a8f07fd2c2fc01e3deea5a495b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t connection_sendmsg </td>
          <td>(</td>
          <td class="paramtype">WConnection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct msghdr *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the underlying system call on <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a>'s file descriptor. </p>
<dl class="section return"><dt>Returns</dt><dd>Same as what the related systemcall returns</dd></dl>
<p>This function calls the system call with the same name. If the socket is ready for the required function it returns immediately, otherwise it blocks in the user-level (blocks <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> not <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a>), and polls the file descriptor until it becomes ready.</p>
<p>The return results is the same as the underlying system call except that the following condition is never true when the function returns: (res == -1) &amp;&amp; (errno == EAGAIN || errno == EWOULDBLOCK)</p>
<p>which means the <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a> object does the polling and only returns when an error occurs or the socket is ready. </p>

</div>
</div>
<a class="anchor" id="a6ff47c532b5903b220818e30ac8293d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t connection_sendto </td>
          <td>(</td>
          <td class="paramtype">WConnection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sockfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>dest_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the underlying system call on <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a>'s file descriptor. </p>
<dl class="section return"><dt>Returns</dt><dd>Same as what the related systemcall returns</dd></dl>
<p>This function calls the system call with the same name. If the socket is ready for the required function it returns immediately, otherwise it blocks in the user-level (blocks <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> not <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a>), and polls the file descriptor until it becomes ready.</p>
<p>The return results is the same as the underlying system call except that the following condition is never true when the function returns: (res == -1) &amp;&amp; (errno == EAGAIN || errno == EWOULDBLOCK)</p>
<p>which means the <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a> object does the polling and only returns when an error occurs or the socket is ready. </p>

</div>
</div>
<a class="anchor" id="a077ae4256e6e0de88a6d099d63d868f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connection_socket </td>
          <td>(</td>
          <td class="paramtype">WConnection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as socket syscall, set the fd for current connection. </p>
<dl class="section return"><dt>Returns</dt><dd>same as socket syscall The unerlying socket is always nonbelocking. This is achieved by adding a (| SOCK_NONBLOCK) to type, thus requires linux kernels &gt; 2.6.27 </dd></dl>

</div>
</div>
<a class="anchor" id="aa0250cd403890768ddba33a50e5293d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t connection_write </td>
          <td>(</td>
          <td class="paramtype">WConnection *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the underlying system call on <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a>'s file descriptor. </p>
<dl class="section return"><dt>Returns</dt><dd>Same as what the related systemcall returns</dd></dl>
<p>This function calls the system call with the same name. If the socket is ready for the required function it returns immediately, otherwise it blocks in the user-level (blocks <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> not <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a>), and polls the file descriptor until it becomes ready.</p>
<p>The return results is the same as the underlying system call except that the following condition is never true when the function returns: (res == -1) &amp;&amp; (errno == EAGAIN || errno == EWOULDBLOCK)</p>
<p>which means the <a class="el" href="classConnection.html" title="Represents a network connection. ">Connection</a> object does the polling and only returns when an error occurs or the socket is ready. </p>

</div>
</div>
<a class="anchor" id="a7f5eb5dfc073dddbb7de5117a5f8bb3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WkThread* kThread_create </td>
          <td>(</td>
          <td class="paramtype">WCluster *&#160;</td>
          <td class="paramname"><em>cluster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="ae846688b27c80029594aa2b67a1db453"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kThread_destroy </td>
          <td>(</td>
          <td class="paramtype">WkThread *&#160;</td>
          <td class="paramname"><em>kt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a517c809c42e5efbcb234ab471d6a274f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WkThread* kThread_get_current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the pointer to the current <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>current <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a></dd></dl>
<p>This is necessary when a <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> wants to find which <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a> it is being executed over. </p>

</div>
</div>
<a class="anchor" id="a739e9a04fd415ab87870c1e971742e4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_t kThread_get_current_pthread_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the native handle for the kernel thread </p>
<dl class="section return"><dt>Returns</dt><dd>native handle for the <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a></dd></dl>
<p>In linux this is pthread_t representation of the thread. </p>

</div>
</div>
<a class="anchor" id="aa78baa2ebc4d541e075d5ac481269cc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_t kThread_get_pthread_id </td>
          <td>(</td>
          <td class="paramtype">WkThread *&#160;</td>
          <td class="paramname"><em>kt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the native handle for the kernel thread </p>
<dl class="section return"><dt>Returns</dt><dd>native handle for the <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a></dd></dl>
<p>In linux this is pthread_t representation of the thread. </p>

</div>
</div>
<a class="anchor" id="a72d80325ab48650187c1785199546ad2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t kThread_get_total_number_of_kThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>total number of kThreads running under the program. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a399f1731f55f8b96c675a6ad0b95fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mutex_acquire </td>
          <td>(</td>
          <td class="paramtype">WMutex *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>acquire the mutex </p>
<dl class="section return"><dt>Returns</dt><dd>true if it was acquired, false otherwise</dd></dl>
<p>The return value is only for when timeouts are implemented </p>

</div>
</div>
<a class="anchor" id="a4eedd424319e0496a248313292dc6fb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WMutex* mutex_create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a90f88f3df3a2dcd5dfb38b193582c203"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mutex_destroy </td>
          <td>(</td>
          <td class="paramtype">WMutex *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a46276d6fc0bb28fa51bdaa283ce25e81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mutex_release </td>
          <td>(</td>
          <td class="paramtype">WMutex *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>release the <a class="el" href="classMutex.html" title="A user-level Mutex. ">Mutex</a> </p>

</div>
</div>
<a class="anchor" id="af1ffa94dec85175c95050dfc5ca43775"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ownerlock_acquire </td>
          <td>(</td>
          <td class="paramtype">WOwnerLock *&#160;</td>
          <td class="paramname"><em>olock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="ae660d3dac08a4bdc8aadc9be061ac27c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WOwnerLock* ownerlock_create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a3c58b151ee7b8b5aa72bdb2c3b2ec954"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ownerlock_destroy </td>
          <td>(</td>
          <td class="paramtype">WOwnerLock *&#160;</td>
          <td class="paramname"><em>olock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a0d52ca13b0fdd683f06e0a0827d4c00a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ownerlock_release </td>
          <td>(</td>
          <td class="paramtype">WOwnerLock *&#160;</td>
          <td class="paramname"><em>olock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a50871266a50c5bc215f8a2ce43da9242"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WSemaphore* semaphore_create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classSemaphore.html" title="A user-level Semaphore. ">Semaphore</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Initial value of the <a class="el" href="classSemaphore.html" title="A user-level Semaphore. ">Semaphore</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a904d4b9b3a1cf0eb4ce5884d1c23163f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void semaphore_destroy </td>
          <td>(</td>
          <td class="paramtype">WSemaphore *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="ae5d486fae5c32dc6e7f843f99b41f9a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool semaphore_p </td>
          <td>(</td>
          <td class="paramtype">WSemaphore *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrement the value of the <a class="el" href="classSemaphore.html" title="A user-level Semaphore. ">Semaphore</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether it was successful or not </dd></dl>

</div>
</div>
<a class="anchor" id="a34f0fa11b8e1ad60c8aa55c506d392d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void semaphore_v </td>
          <td>(</td>
          <td class="paramtype">WSemaphore *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>increment the value of the <a class="el" href="classSemaphore.html" title="A user-level Semaphore. ">Semaphore</a> </p>

</div>
</div>
<a class="anchor" id="acfd14530be3fea8cf9204f70cd9e4b9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WuThread* uThread_create </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>joinable</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> with a given stack size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ss</td><td>stack size </td></tr>
    <tr><td class="paramname">joinable</td><td>Whether this thread is joinable or detached </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a new <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a></dd></dl>
<p>This function relies on a <a class="el" href="classuThreadCache.html" title="Data structure to cache uThreads. ">uThreadCache</a> structure and does not always allocate the stack. </p>

</div>
</div>
<a class="anchor" id="a5bc04089100a2af87d1b94c5c6a58fdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uThread_detach </td>
          <td>(</td>
          <td class="paramtype">WuThread *&#160;</td>
          <td class="paramname"><em>ut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach a joinable thread. </p>

</div>
</div>
<a class="anchor" id="ae327f6468bf4aeba31243ef5cd49fcdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WuThread* uThread_get_current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the current running <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the current <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> </dd></dl>

</div>
</div>
<a class="anchor" id="add2aa0519b9655b2a295653f8fab0a01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t uThread_get_id </td>
          <td>(</td>
          <td class="paramtype">WuThread *&#160;</td>
          <td class="paramname"><em>ut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the ID of this <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> </p>
<dl class="section return"><dt>Returns</dt><dd>ID of the <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0aff17b56e583c76add0913790f472f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t uThread_get_total_number_of_uThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>Total number of uThreads in the program</dd></dl>
<p>This number does not include mainUT or IOUTs </p>

</div>
</div>
<a class="anchor" id="a350a033acc8970710b72d31b0ead6d4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool uThread_join </td>
          <td>(</td>
          <td class="paramtype">WuThread *&#160;</td>
          <td class="paramname"><em>ut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> to finish execution and exit. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether join was successful or failed </dd></dl>

</div>
</div>
<a class="anchor" id="ae884ed2490c204350df69b54ebe62c18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uThread_migrate </td>
          <td>(</td>
          <td class="paramtype">WCluster *&#160;</td>
          <td class="paramname"><em>cluster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move the <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> to the provided cluster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster</td><td>This function is used to migrate the <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> to another <a class="el" href="classCluster.html" title="Scheduler and Cluster of kThreads. ">Cluster</a>. Migration is useful specially if clusters form a pipeline of execution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af6fe0d5fb1b8c45f0b6c7f21c12721fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uThread_start </td>
          <td>(</td>
          <td class="paramtype">WuThread *&#160;</td>
          <td class="paramname"><em>ut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WCluster *&#160;</td>
          <td class="paramname"><em>cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg2</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg3</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>start the <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> by calling the function passed to it </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster</td><td>The cluster that function belongs to. </td></tr>
    <tr><td class="paramname">func</td><td>a pointer to a function that should be executed by the <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a>. </td></tr>
    <tr><td class="paramname">arg1</td><td>first argument of the function (can be nullptr) </td></tr>
    <tr><td class="paramname">arg2</td><td>second argument of the function (can be nullptr) </td></tr>
    <tr><td class="paramname">arg3</td><td>third argument of the function (can be nullptr)</td></tr>
  </table>
  </dd>
</dl>
<p>After creating the <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> and allocating the stack, the start() function should be called to get the <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> going. </p>

</div>
</div>
<a class="anchor" id="a042b0598787dfca933132305f9324e4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uThread_terminate </td>
          <td>(</td>
          <td class="paramtype">WuThread *&#160;</td>
          <td class="paramname"><em>ut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminates the <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a>. </p>
<p>By calling this function <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> is being terminated and <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> object is either destroyed or put back into the cache. </p>

</div>
</div>
<a class="anchor" id="a4d8091f1b2362987907c2fba1c77af5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uThread_yield </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> to yield. </p>
<p><a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> give up the execution context and place itself back on the ReadyQueue of the <a class="el" href="classCluster.html" title="Scheduler and Cluster of kThreads. ">Cluster</a>. If there is no other uThreads available to switch to, the current <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> continues execution. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun May 8 2016 16:15:13 for uThreads by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>

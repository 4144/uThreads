<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>uThreads: uThreads: Concurrent User-level Threads in C++</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">uThreads
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">uThreads: Concurrent User-level Threads in C++ </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>uThreads is a concurrent library based on cooperative scheduling of user-level threads implemented in C++. User-level threads are lightweight threads that execute on top of kernel threads to provide concurrency as well as parallelism. Kernel threads are necessary to utilize processors, but they come with the following drawbacks:</p>
<ul>
<li>Each suspend/resume operation involves a kernel context switch</li>
<li>Thread preemption causes additional overhead</li>
<li>Thread priorities and advanced scheduling causes additional overhead</li>
</ul>
<p>Cooperative user-level threads, on the other hand, provide light weight context switches and omit the additional overhead of preemption and kernel scheduling. Most Operating Systems only support a 1:1 thread mapping (1 user-level thread to 1 kernel-level thread), where multiple kernel threads execute at the same time to utilize multiple cores and provide parallelism. e.g., Linux supports only 1:1 thread mapping. There is also N:1 thread mapping, where multiple user-level threads can be mapped to a single kernel-level thread. The kernel thread is not aware of the user-level threads existence. With N:1 mapping if the application blocks at the kernel level, it means blocking all user-level threads and application stops executing. This problem can be solved by using multiple kernel-level threads and map multiple user-level threads to each of them. Thus, creating the third scenario with M:N or hybrid mapping. e.g., <a href="https://plg.uwaterloo.ca/usystem/uC++.html">uC++</a> supports M:N mapping.</p>
<p>uThreads supports M:N mapping of <em>uThreads</em> (user-level threads) over <em>kThreads</em> (kernel-level threads) with cooperative scheduling. kThreads can be grouped together by <em>Clusters</em>, and uThreads can migrate among Clusters. Figure 1 shows the structure of an application implemented using uThreads. Each part is explained further in the following.</p>
<div class="image">
<img src="architecture.png" alt="architecture.png"/>
<div class="caption">
Figure 1: uThreads Architecture</div></div>
<p> <b>Clusters</b> are used to group kThreads together. Each <a class="el" href="classCluster.html" title="Scheduler and Cluster of kThreads. ">Cluster</a> can contain one or more kThreads, but each <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a> only belongs to a single <a class="el" href="classCluster.html" title="Scheduler and Cluster of kThreads. ">Cluster</a>. Each <a class="el" href="classCluster.html" title="Scheduler and Cluster of kThreads. ">Cluster</a> includes a single <em>ReadyQueue</em> which is used to schedule uThreads over kThreads in that <a class="el" href="classCluster.html" title="Scheduler and Cluster of kThreads. ">Cluster</a>. Application programmer decides how many kThreads belong to a ReadyQueue by assigning them to the related <a class="el" href="classCluster.html" title="Scheduler and Cluster of kThreads. ">Cluster</a>.</p>
<p><b>kThreads</b> are kernel-level threads (std::thread), that are the main vehicle to utilize cores and execute the program. Each <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a> can only pull uThreads from the ReadyQueue of the <a class="el" href="classCluster.html" title="Scheduler and Cluster of kThreads. ">Cluster</a> it belongs to, but it can push uThreads to the ReadyQueue of any <a class="el" href="classCluster.html" title="Scheduler and Cluster of kThreads. ">Cluster</a> in the application. The former can happen when uThreads <em>yield</em> or <em>block</em> at user level, and the latter happens when uThreads <em>migrate</em> to another <a class="el" href="classCluster.html" title="Scheduler and Cluster of kThreads. ">Cluster</a>. Migration let the code execute on a different set of kThreads based on the requirements of the code.</p>
<p><b>uThreads</b> are the main building blocks of the library. They are either sitting in the ReadyQueue waiting to be picked by a <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a>, running by a <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a>, or blocked and waiting for an event to occur. uThreads are being scheduled cooperatively over Clusters, they can either yield, migrate or block on an event to let other uThreads utilized the same <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a> they are being executed over.</p>
<p>Each application has at least one <a class="el" href="classCluster.html" title="Scheduler and Cluster of kThreads. ">Cluster</a>, one <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a> and one <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a>. Each C++ application has at least one thread of execution (kernel thread) which runs the <em>main()</em> function. A C++ application that is linked with uThreads library, upon execution, creates a <em>defaultCluster</em>, a wrapper around the main execution thread and call it <em>defaultkThread</em>, and also a <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> called <em>mainUT</em> to take over the defaultkThread stack and run the <em>main</em> function.</p>
<p>In addition, each <a class="el" href="classCluster.html" title="Scheduler and Cluster of kThreads. ">Cluster</a> by default has a <em>Poller <a class="el" href="classkThread.html" title="Object to represent kernel threads. ">kThread</a></em> which is responsible for polling the network devices, and multiplexing network events over the <a class="el" href="classCluster.html" title="Scheduler and Cluster of kThreads. ">Cluster</a>. uThreads provide a user-level blocking network events, where network calls are non-blocking at the kernel-level but uThreads block on network events if the device is not ready for read/write. The poller thread is thus responsible for unblock the uThreads upon receiving the related network event. The poller thread is using <em>edge triggered epoll</em> in Linux, and the model is similar to <a href="https://golang.org/">Golang</a>.</p>
<p>By default there is a <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> cache to cache uThreads that finished executing and avoid the extra overhead of memory allocation. Currently, this cache only supports uThreads with same stack size and does not support the scenario where stack sizes are different. This feature will be added in the near future.</p>
<h2>Migration and Joinable uThreads </h2>
<p>uThreads can be joinable, where upon creating the creator has to wait for them to finish execution and join with them. So there are two ways to execute a piece of code on another <a class="el" href="classCluster.html" title="Scheduler and Cluster of kThreads. ">Cluster</a>:</p>
<ul>
<li><b>Migration:</b> <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> can migrate to another <a class="el" href="classCluster.html" title="Scheduler and Cluster of kThreads. ">Cluster</a> to execute a piece of code and it can either migrate back to the previous <a class="el" href="classCluster.html" title="Scheduler and Cluster of kThreads. ">Cluster</a> or continue the execution on the same <a class="el" href="classCluster.html" title="Scheduler and Cluster of kThreads. ">Cluster</a> or migrate to a different <a class="el" href="classCluster.html" title="Scheduler and Cluster of kThreads. ">Cluster</a>. The following code demonstrates a simple scenario to migrate to a different cluster and back, assuming <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> is executing on the <em>defaultCluster</em>: <div class="fragment"><div class="line"><a class="code" href="classCluster.html">Cluster</a> *cluster1;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> func(){</div>
<div class="line">    <span class="comment">// some code </span></div>
<div class="line">    migrate(*cluster1);</div>
<div class="line">    <span class="comment">// code to run on cluster1</span></div>
<div class="line">    migrate(<a class="code" href="classCluster.html#a8461d9e484561668256e4aa32ec60fd1">Cluster::getDefaultCluster</a>());</div>
<div class="line"> <span class="comment">// some more code </span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line"></div>
<div class="line">    cluster1 = <span class="keyword">new</span> <a class="code" href="classCluster.html">Cluster</a>();</div>
<div class="line">    <a class="code" href="classkThread.html">kThread</a> kt(*cluster1);</div>
<div class="line">    <a class="code" href="classuThread.html">uThread</a> *ut = <a class="code" href="classuThread.html#a4c1bc2aa32ac06dbbaf932152562b7b0">uThread::create</a>(); </div>
<div class="line">    ut-&gt;<a class="code" href="classuThread.html#a2a5c71fa82f4f3e6dd5437e5be7c7184">start</a>(<a class="code" href="classCluster.html#a8461d9e484561668256e4aa32ec60fd1">Cluster::getDefaultCluster</a>(), func);</div>
<div class="line">.</div>
<div class="line">.</div>
<div class="line">.</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><b>Joinable thread:</b> Create a joinable thread on the remote <a class="el" href="classCluster.html" title="Scheduler and Cluster of kThreads. ">Cluster</a> and wait for it to finish execution. While waiting, the <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a> is blocked at user-level and will be unblocked by the newly created <a class="el" href="classuThread.html" title="user-level threads (fiber) ">uThread</a>. <div class="fragment"><div class="line"><a class="code" href="classCluster.html">Cluster</a> *cluster1;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> run(){</div>
<div class="line">    <span class="comment">//code to run on cluster1</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">void</span> func(){</div>
<div class="line">    <span class="comment">// some code </span></div>
<div class="line">    <a class="code" href="classuThread.html">uThread</a> *ut2 = <a class="code" href="classuThread.html#a4c1bc2aa32ac06dbbaf932152562b7b0">uThread::create</a>(<span class="keyword">true</span>); <span class="comment">//create a joinable thread</span></div>
<div class="line">    ut2-&gt;<a class="code" href="classuThread.html#a2a5c71fa82f4f3e6dd5437e5be7c7184">start</a>(cluster1, run);</div>
<div class="line">    ut2-&gt;<a class="code" href="classuThread.html#a7230cc0873429c99e07866814a682f8b">join</a>(); <span class="comment">//wait for ut2 to finish execution and join</span></div>
<div class="line"> <span class="comment">// some more code </span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line"></div>
<div class="line">    cluster1 = <span class="keyword">new</span> <a class="code" href="classCluster.html">Cluster</a>();</div>
<div class="line">    <a class="code" href="classkThread.html">kThread</a> kt(*cluster1);</div>
<div class="line">    <a class="code" href="classuThread.html">uThread</a> *ut = <a class="code" href="classuThread.html#a4c1bc2aa32ac06dbbaf932152562b7b0">uThread::create</a>(); </div>
<div class="line">    ut-&gt;<a class="code" href="classuThread.html#a2a5c71fa82f4f3e6dd5437e5be7c7184">start</a>(<a class="code" href="classCluster.html#a8461d9e484561668256e4aa32ec60fd1">Cluster::getDefaultCluster</a>(), func);</div>
<div class="line">.</div>
<div class="line">.</div>
<div class="line">.</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ul>
<h2>User-level Blocking Synchronization Primitives </h2>
<p>uThreads also provides user-level blocking synchronization and mutex primitives. It has basic <a class="el" href="classMutex.html" title="A user-level Mutex. ">Mutex</a>, Condition Variable and <a class="el" href="classSemaphore.html" title="A user-level Semaphore. ">Semaphore</a>. You can find examples of their usage under <em>test</em> directory in the <a href="https://github.com/samanbarghi/uThreads">github repo</a>.</p>
<h2>Examples </h2>
<p>You can find various examples under the test directory in the <a href="https://github.com/samanbarghi/uThreads">github repo</a>. There is an <a href="https://github.com/samanbarghi/uThreads/blob/master/test/EchoClient.cpp">EchoClient</a> and <a href="https://github.com/samanbarghi/uThreads/blob/master/test/EchoServer.cpp">EchoServer</a> implemented using uThreads.</p>
<p>There is also a simple <a href="https://github.com/samanbarghi/uThreads/blob/master/test/webserver.cpp">webserver</a> to test uThreads functionality.</p>
<p>For performance comparisons, memached code has been updated to use uThreads instead of event loops (except the thread that accepts connections), where tasks are assigned to uThreads instead of using the underlying event library. The code can be found <a href="https://github.com/samanbarghi/memcached/tree/uThreads">here</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun May 8 2016 16:15:14 for uThreads by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
